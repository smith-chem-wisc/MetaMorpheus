using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Easy.Common.Extensions;
using MzLibUtil;
using System.Text.RegularExpressions;

namespace Readers.InternalResults;

public class MetaMorpheusProseFile
{
    public static readonly string ExpectedFileName = "AutoGeneratedManuscriptProse";
    private readonly string[] CleanedSpectraFileNames;
    public string MetaMorpheusVersion { get; private set; }
    public string FilePath { get; init; }
    public string[] SpectraFilePaths { get; private set; }
    public string[] DatabasePaths { get; private set; }

    public MetaMorpheusProseFile(string filePath)
    {
        FilePath = filePath;
        SpectraFilePaths = [];
        DatabasePaths = [];
        MetaMorpheusVersion = "Unknown";
        ParseAllInfo();
        CleanedSpectraFileNames = SpectraFilePaths
            .Select(p => p.GetPeriodTolerantFilenameWithoutExtension())
            .Select(name => name
                .Replace("-calib", "")
                .Replace("-averaged", ""))
            .ToArray();
    }

    /// <summary>
    /// Take in an averaged spectra file path (ends with -averaged). Find the unaveraged file path by removing the "-averaged" suffix and returning the full path to the unaveraged file with consideration for calibrated files (ends with -calib) and with consideration for swapping the file extension to .mzML if necessary.
    /// </summary>
    /// <param name="averagedFilePath"></param>
    /// <returns></returns>
    public string? FindUnaveragedFile(string averagedFilePath)
    {
        if (string.IsNullOrEmpty(averagedFilePath) || !File.Exists(averagedFilePath))
            return null;

        // Remove the "-averaged" suffix
        var cleanedAveragedFileName = Path.GetFileNameWithoutExtension(averagedFilePath)
            .Replace("-averaged", "").Replace("-calib", "");

        // Find the index of the cleaned file name in the cleaned spectra file names
        var index = Array.IndexOf(CleanedSpectraFileNames, cleanedAveragedFileName);
        if (index < 0 || index >= SpectraFilePaths.Length)
            return null;

        var unaveragedPath = SpectraFilePaths[index];
        // Ensure the file exists before returning
        if (!File.Exists(unaveragedPath))
            return null;

        return unaveragedPath;
    }

    public static MetaMorpheusProseFile? LocateInDirectory(string directoryPath)
    {
        if (!Directory.Exists(directoryPath))
            return null;

        // Find all prose files
        var files = Directory.GetFiles(directoryPath, $"{ExpectedFileName}.txt", SearchOption.AllDirectories);

        // No prose files in directory
        if (files.Length == 0)
            return null;

        // If multiple match the pattern, find the least nested. 
        var filePath = files.MinBy(p => p.Length);

        try
        {
            var proseFile = new MetaMorpheusProseFile(filePath);
            return proseFile;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading MetaMorpheus Prose file at {filePath}: {ex.Message}");
            return null;
        }
    }

    private void ParseAllInfo()
    {
        var lines = File.ReadAllLines(FilePath);
        var specIndex = lines.IndexOf("Spectra files: ");
        var dbIndex = lines.IndexOf("Databases:");

        // Parse MetaMorpheus version from the first few lines
        // Example: "The data analysis was performed using MetaMorpheus version 1.0.7, available at ..."
        var versionPattern = @"MetaMorpheus version ([\d\.]+)";
        MetaMorpheusVersion = "Unknown";
        foreach (var line in lines.Take(10))
        {
            var match = Regex.Match(line, versionPattern, RegexOptions.IgnoreCase);
            if (match.Success)
            {
                MetaMorpheusVersion = match.Groups[1].Value;
                break;
            }
        }

        var spec = new List<string>();
        var db = new List<string>();
        for (int i = specIndex + 1; i < dbIndex; i++)
        {
            spec.Add(lines[i].Trim());
        }

        // Define a regex pattern to match file paths
        string pattern = @"[A-Z]:\\[^\s]+";
        foreach (Match match in Regex.Matches(lines[dbIndex + 1], pattern))
        {
            db.Add(match.Value);
        }

        SpectraFilePaths = spec.ToArray();
        DatabasePaths = db.ToArray();
    }
}
